%% Search for a specified operating point for the model - lumped_neck.
%
% This MATLAB script is the command line equivalent of the trim model
% tab in linear analysis tool with current specifications and options.
% It produces the exact same operating points as hitting the Trim button.

% MATLAB(R) file generated by MATLAB(R) 9.11 and Simulink Control Design (TM) 6.0.
%
% Generated on: 21-Apr-2022 15:01:24

%% Specify the model name
model = 'lumped_neck';

pitch_operating_points = [-45, 0, 45]; % degrees
Ts = 1e-3;
%% Create the operating point specification object.
% Create the options
opt = findopOptions('DisplayReport','iter');

ls = cell(1,length(pitch_operating_points));
op_points_pitch = cell(1,length(pitch_operating_points));
for i = 1:length(pitch_operating_points)
   [ls{i}, op_points_pitch{i}] = linearize_pitch(model, pitch_operating_points(i), opt, 1);
end

%% Discretize models

ld = cell(1, length(pitch_operating_points));

for i = 1:length(pitch_operating_points)
    ld{i} = c2d(ls{i}, Ts, 'tustin');
end

%% plot of poles and zeros
figure()
pzmap(ld{:})
grid on

figure()
step(ls{:}, 1)
grid minor
legend({'0°','10°','35°', '45°'}, 'location', 'northwest')
ylabel('Pitch (deg)')
title('Step response of linearized pitch model at different operating points')
subtitle('from pitch torque to pitch angle')


figure()
step(ld{:}, 1)
grid minor
legend({'-45°','0°', '45°'}, 'location', 'northwest')
ylabel('Pitch (deg)')
title('Step response of linearized pitch model at different operating points')
subtitle('from pitch torque to pitch angle')

%% print zpk form
tol = sqrt(eps) * 10;
minreal(zpk(ls{1}), tol)
minreal(zpk(ls{2}), tol)
minreal(zpk(ls{3}), tol)
minreal(zpk(ls{4}), tol)

%% Ctrl

% define the tunable controller
Gc = tunablePID('Gc', 'PID', Ts);
Gc.IFormula = 'trapezoidal';
Gc.DFormula = 'trapezoidal';
Gc.Kp.Minimum = 0;    Gc.Kp.Maximum = inf;
Gc.Ki.Minimum = 0;    Gc.Ki.Maximum = inf;
Gc.Kd.Minimum = 0;    Gc.Kd.Maximum = inf;
Gc.Tf.Minimum = 2*Ts; Gc.Tf.Maximum = 10*Ts;    % N = 1/Tf
Gc.TimeUnit = 'seconds';

% define requirements
responsetime = 0.2;
dcerror = 0.1;
peakerror = 1.2;

peak = 0.1;
tSettle = 1;

d = AnalysisPoint('d1');
Gcl0_1 = feedback(ld{1} * d * Gc, 1);
Gcl0_1.InputName = 'r';
Gcl0_1.OutputName = 'y1';
Rtrack_1 = TuningGoal.Tracking('r', 'y1', responsetime, dcerror, peakerror);
Rreject_1 = TuningGoal.StepRejection('d1', 'y1', peak, tSettle);

d = AnalysisPoint('d2');
Gcl0_2 = feedback(ld{2} * d * Gc, 1);
Gcl0_2.InputName = 'r';
Gcl0_2.OutputName = 'y';
Rtrack_2 = TuningGoal.Tracking('r', 'y', responsetime, dcerror, peakerror);
Rreject_2 = TuningGoal.StepRejection('d2', 'y', peak, tSettle);

d = AnalysisPoint('d3');
Gcl0_3 = feedback(ld{3} * d * Gc, 1);
Gcl0_3.InputName = 'r';
Gcl0_3.OutputName = 'y';
Rtrack_3 = TuningGoal.Tracking('r', 'y', responsetime, dcerror, peakerror);
Rreject_3 = TuningGoal.StepRejection('d3', 'y', peak, tSettle);

aa = [Gcl0_1 Gcl0_2 Gcl0_3];

tuneopts = systuneOptions('RandomStart', 10);

Gcl = systune(aa, [Rtrack_1, Rtrack_2, Rtrack_3], [Rreject_1, Rreject_2, Rreject_3], tuneopts);
tunedValue = getTunedValue(Gcl);
Gc = tunedValue.Gc;


% plot results
figure('color', 'white');
h1 = subplot(2, 1, 1);
h2 = subplot(2, 1, 2);

stepplot(h1, Gcl);
title('Step Response');
grid('minor');

stepplot(h2, getIOTransfer(Gcl, 'd', 'y'));
title('Step Disturbance Rejection');
grid('minor');

linkaxes([h1 h2], 'x');
